<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>y的小站</title>
  
  <subtitle>一个低调的无名小站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ysir.me/"/>
  <updated>2017-12-20T14:48:27.804Z</updated>
  <id>http://ysir.me/</id>
  
  <author>
    <name>y</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>The use of Swift 3 @objc inference in Swift 4 mode is deprecated?</title>
    <link href="http://ysir.me/2017/12/20/The-use-of-Swift-3-objc-inference-in-Swift-4-mode-is-deprecated/"/>
    <id>http://ysir.me/2017/12/20/The-use-of-Swift-3-objc-inference-in-Swift-4-mode-is-deprecated/</id>
    <published>2017-12-20T14:38:27.000Z</published>
    <updated>2017-12-20T14:48:27.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>升级 Xcode 后产生了警告：The use of Swift 3 @objc inference in Swift 4 mode is deprecated?</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>修改项目 Targets 的 Build Settings，将 Swift 3 @obj Interface 设置为 Default。</p><p><img src="https://i.loli.net/2017/12/20/5a3a762798978.png" alt=""></p><p>参考</p><p><a href="https://stackoverflow.com/questions/44379348/the-use-of-swift-3-objc-inference-in-swift-4-mode-is-deprecated" target="_blank" rel="external">The use of Swift 3 @objc inference in Swift 4 mode is deprecated?</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;升级 Xcode 后产生了警告：The use of Swift 3 @objc inference in Swift 4 mode is 
      
    
    </summary>
    
      <category term="Swift" scheme="http://ysir.me/categories/Swift/"/>
    
    
      <category term="Swift" scheme="http://ysir.me/tags/Swift/"/>
    
      <category term="iOS" scheme="http://ysir.me/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>15款免费好用的Mac Apps</title>
    <link href="http://ysir.me/2017/09/03/15%E6%AC%BE%E5%85%8D%E8%B4%B9%E5%A5%BD%E7%94%A8%E7%9A%84Mac-Apps/"/>
    <id>http://ysir.me/2017/09/03/15款免费好用的Mac-Apps/</id>
    <published>2017-09-03T14:31:16.000Z</published>
    <updated>2017-09-07T14:13:05.239Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<br><a href="https://www.maketecheasier.com/free-useful-micro-apps-for-mac/" target="_blank" rel="external">Top 15 Free and Useful Micro Apps for Mac</a></p><h2 id="1-Skitch"><a href="#1-Skitch" class="headerlink" title="1. Skitch"></a>1. <a href="https://evernote.com/intl/zh-cn/products/skitch" target="_blank" rel="external">Skitch</a></h2><p><img src="https://i.loli.net/2017/09/05/59aea2bc22c42.jpg" alt=""></p><p>来自 Evernote 的这款截屏应用能够帮助你截取屏幕上的任何东西，并且保存到 Evernote 账户上。<a href="https://evernote.com/intl/zh-cn/products/skitch" target="_blank" rel="external">Skitch</a> 是 Mac 独占应用。</p><h2 id="2-Simplenote"><a href="#2-Simplenote" class="headerlink" title="2. Simplenote"></a>2. <a href="https://simplenote.com/" target="_blank" rel="external">Simplenote</a></h2><p><img src="https://i.loli.net/2017/09/05/59aea3bf261d5.jpg" alt=""></p><p>这款应用能够让你快速建立和收藏笔记并且<a href="https://www.maketecheasier.com/setup-ultimate-multi-platform-writing-environment-with-simplenote/" target="_blank" rel="external">同步到所有设备</a>，它没有 Evernote 那么复杂的功能，简单正是它的特点。</p><h2 id="3-Jumpcut"><a href="#3-Jumpcut" class="headerlink" title="3. Jumpcut"></a>3. <a href="http://jumpcut.sourceforge.net/" target="_blank" rel="external">Jumpcut</a></h2><p><img src="https://i.loli.net/2017/09/05/59aea3bf252e3.png" alt=""></p><p>Jumpcut 可能是<a href="https://www.maketecheasier.com/jumpcut-a-must-have-mac-clipboard/" target="_blank" rel="external">最轻量的剪切板管理器</a>，它没有很多花哨的特性。它可以容纳几乎无限条剪贴板历史记录，并且提供简单的方式来快速使用它们。</p><h2 id="4-Calq"><a href="#4-Calq" class="headerlink" title="4. Calq"></a>4. <a href="http://www.katoemba.net/makesnosenseatall/calq/" target="_blank" rel="external">Calq</a></h2><p><img src="https://i.loli.net/2017/09/05/59aea3bf31675.jpg" alt=""></p><p>如果你需要<a href="https://www.maketecheasier.com/calq-a-quick-calculator-at-your-fingertips/" target="_blank" rel="external">快速地启动一个简单计算器</a>，可以尝试一下 <a href="http://www.katoemba.net/makesnosenseatall/calq/" target="_blank" rel="external">Calq</a>。使用快捷键快速唤出，输入数字就可以得到结果，并且可以复制粘贴结果到其他地方。</p><h2 id="5-f-lux"><a href="#5-f-lux" class="headerlink" title="5. f.lux"></a>5. <a href="https://justgetflux.com/" target="_blank" rel="external">f.lux</a></h2><p><img src="https://i.loli.net/2017/09/05/59aea3bf32a71.jpg" alt=""></p><p>如果你大部分时间的盯着电脑屏幕，你会发现你的眼睛在晚上会比在白天更容易感到疲惫。这款应用可以<a href="https://www.maketecheasier.com/flux-prevent-computer-related-eye-problems/" target="_blank" rel="external">在晚上自动调节你的屏幕颜色</a>来让你的眼睛感到舒服，并且在白天让显示器恢复成正常状态。</p><h2 id="6-Bean"><a href="#6-Bean" class="headerlink" title="6. Bean"></a>6. <a href="http://www.bean-osx.com/Bean.html" target="_blank" rel="external">Bean</a></h2><p><img src="https://i.loli.net/2017/09/05/59aea3bf3ed62.jpg" alt=""></p><p>一款轻量级的文本编辑器。</p><h2 id="7-CheatSheet"><a href="#7-CheatSheet" class="headerlink" title="7. CheatSheet"></a>7. <a href="https://www.mediaatelier.com/CheatSheet/" target="_blank" rel="external">CheatSheet</a></h2><p><img src="https://i.loli.net/2017/09/05/59aea3bf3da5a.jpg" alt=""></p><p>使用鼠标来操作电脑没有使用快捷键的方式快。但是记住这些快捷键十分困难，除非你使用 CheatSheet。长按 Command 键唤醒 CheatSheet 来显示当前使用的 App 的所有可用快捷键。</p><h2 id="8-SelfControl"><a href="#8-SelfControl" class="headerlink" title="8. SelfControl"></a>8. <a href="https://selfcontrolapp.com/" target="_blank" rel="external">SelfControl</a></h2><p><img src="https://i.loli.net/2017/09/05/59aea3bf338c0.jpg" alt=""></p><p>在你工作的时候，是否网络上的东西会分散你的注意力。因此你需要<a href="https://www.maketecheasier.com/work-with-ultimate-peace-and-without-any-web-distraction-in-mac/" target="_blank" rel="external">这款应用</a>。仅仅只需把网站添加到黑名单，设置计时器，然后开始工作。直到计时器结束，您将无法访问这些站点——即使你重新启动计算机或删除这个应用。</p><h2 id="9-Unarchiver"><a href="#9-Unarchiver" class="headerlink" title="9. Unarchiver"></a>9. <a href="https://theunarchiver.com/" target="_blank" rel="external">Unarchiver</a></h2><p><img src="https://i.loli.net/2017/09/05/59aea5f973181.jpg" alt=""></p><p>压缩一直是帮助用户管理和分享文件的最古老的方法之一。有许多可用的压缩格式以及专用的应用程序来管理它们。Unarchiver 这一个应用就可以解压多种不同格式的压缩文件。</p><h2 id="10-ImageOptim"><a href="#10-ImageOptim" class="headerlink" title="10. ImageOptim"></a>10. <a href="https://imageoptim.com/mac" target="_blank" rel="external">ImageOptim</a></h2><p><img src="https://i.loli.net/2017/09/05/59aea4c3b0d7e.jpg" alt=""></p><p>加快网站访问速度的方法之一就是优化你的网站所使用的图片，ImageOptim 能够让你一次性的处理优化多张图片。</p><h2 id="11-AppCleaner"><a href="#11-AppCleaner" class="headerlink" title="11. AppCleaner"></a>11. <a href="https://freemacsoft.net/appcleaner/" target="_blank" rel="external">AppCleaner</a></h2><p><img src="https://i.loli.net/2017/09/05/59aea4c39f4e3.jpg" alt=""></p><p>虽然 Mac 用户可以通过简单地删除文件来卸载应用，但这种方法常常会留下很多乱七八糟的东西。你需要一个像 AppCleaner 一样的卸载程序来完全的卸载一个应用。</p><h2 id="12-Transmission"><a href="#12-Transmission" class="headerlink" title="12. Transmission"></a>12. <a href="https://transmissionbt.com/" target="_blank" rel="external">Transmission</a></h2><p><img src="https://i.loli.net/2017/09/05/59aea4c3aeef0.jpg" alt=""></p><p>Transmission 是 Mac 上最简单并且最强大的 torrent 客户端。</p><h2 id="13-Apptivate"><a href="#13-Apptivate" class="headerlink" title="13. Apptivate"></a>13. <a href="http://www.apptivateapp.com/" target="_blank" rel="external">Apptivate</a></h2><p><img src="https://i.loli.net/2017/09/05/59aea5c361da8.png" alt=""></p><p>如果系统的快捷键不足以满足你的需求，你可以使用 Apptivate 来创建自定义的快捷键来<a href="https://www.maketecheasier.com/use-apptivate-to-increase-your-productivity/" target="_blank" rel="external">提高生产力</a>。这款应用可以帮助你启动应用，运行脚本，运行 Automator，访问文件等。</p><h2 id="14-Stockmagic"><a href="#14-Stockmagic" class="headerlink" title="14. Stockmagic"></a>14. <a href="http://getstockmagic.com/" target="_blank" rel="external">Stockmagic</a></h2><p><img src="https://i.loli.net/2017/09/05/59aea4c3afc31.jpg" alt=""></p><p>通过 Stockmagic，你可以从菜单栏轻松获取来自 Pixabay 的免费高清图片,你可以搜索图片并且拖放图片到你的文件夹中。</p><h2 id="15-Spectacle"><a href="#15-Spectacle" class="headerlink" title="15. Spectacle"></a>15. <a href="https://www.spectacleapp.com/" target="_blank" rel="external">Spectacle</a></h2><p><img src="https://i.loli.net/2017/09/05/59aea4c3b1d46.jpg" alt=""></p><p>如果你有一点强迫症，必须让你的应用程序窗口完美地对齐，可以使用 Spectacle。它可以设置一个完美的大小和位置来帮助你把你的应用程序窗口放在你的屏幕上。Spectacle 总是隐藏在后台，几乎不消耗系统资源。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文链接：&lt;br&gt;&lt;a href=&quot;https://www.maketecheasier.com/free-useful-micro-apps-for-mac/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Top 15 Free and Useful M
      
    
    </summary>
    
      <category term="翻译" scheme="http://ysir.me/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="http://ysir.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="maketecheasier" scheme="http://ysir.me/tags/maketecheasier/"/>
    
      <category term="Mac" scheme="http://ysir.me/tags/Mac/"/>
    
      <category term="App" scheme="http://ysir.me/tags/App/"/>
    
      <category term="免费" scheme="http://ysir.me/tags/%E5%85%8D%E8%B4%B9/"/>
    
  </entry>
  
  <entry>
    <title>如何在Windows10中关闭IE浏览器</title>
    <link href="http://ysir.me/2017/09/03/%E5%A6%82%E4%BD%95%E5%9C%A8Windows10%E4%B8%AD%E5%85%B3%E9%97%ADIE%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    <id>http://ysir.me/2017/09/03/如何在Windows10中关闭IE浏览器/</id>
    <published>2017-09-03T13:52:54.000Z</published>
    <updated>2017-09-05T13:38:29.826Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<br><a href="https://www.maketecheasier.com/turn-off-internet-explorer-windows10/" target="_blank" rel="external">How to Turn Off Internet Explorer in Windows 10</a></p><p>你不能卸载 IE 浏览器，但你能关闭这个功能。</p><h2 id="为什么-Win10-捆绑了-IE11-浏览器"><a href="#为什么-Win10-捆绑了-IE11-浏览器" class="headerlink" title="为什么 Win10 捆绑了 IE11 浏览器"></a>为什么 Win10 捆绑了 IE11 浏览器</h2><p>Edge 浏览器是为现代页面设计的，那些使用老技术的网站可能不能在 Edge 中正确加载出来。基于这个原因，微软在 Win10 中捆绑了 IE11 来兼容这些旧网站。</p><h2 id="如何在-Win10-中关闭-IE-浏览器"><a href="#如何在-Win10-中关闭-IE-浏览器" class="headerlink" title="如何在 Win10 中关闭 IE 浏览器"></a>如何在 Win10 中关闭 IE 浏览器</h2><ol><li><p>搜索框输入控制面板并打开。</p><p> <img src="https://i.loli.net/2017/09/05/59aea7aed38af.png" alt=""></p></li><li><p>查看方式选择类别，然后点击程序分类。</p><p> <img src="https://i.loli.net/2017/09/05/59aea7aee48ea.png" alt=""></p></li><li><p>在程序和功能中点击”启用或关闭 Windows 功能”</p><p> <img src="https://i.loli.net/2017/09/05/59aea7aee2a4b.png" alt=""></p></li><li><p>找到 Internet Explorer 11 选项，取消它的选中状态。</p><p> <img src="https://i.loli.net/2017/09/05/59aea7aeee110.png" alt=""></p></li><li><p>在弹出的警告框点击确定。</p><p> <img src="https://i.loli.net/2017/09/05/59aea7aeecdad.png" alt=""></p></li><li><p>等待 Window 更新好设置后重启你的电脑。</p><p> <img src="https://i.loli.net/2017/09/05/59aea7aeef6bf.png" alt=""></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文链接：&lt;br&gt;&lt;a href=&quot;https://www.maketecheasier.com/turn-off-internet-explorer-windows10/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;How to Turn Off In
      
    
    </summary>
    
      <category term="翻译" scheme="http://ysir.me/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="http://ysir.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="maketecheasier" scheme="http://ysir.me/tags/maketecheasier/"/>
    
      <category term="Win10" scheme="http://ysir.me/tags/Win10/"/>
    
      <category term="IE" scheme="http://ysir.me/tags/IE/"/>
    
  </entry>
  
  <entry>
    <title>如何在Windows10中使用Emoji表情</title>
    <link href="http://ysir.me/2017/06/08/%E5%A6%82%E4%BD%95%E5%9C%A8Windows10%E4%B8%AD%E4%BD%BF%E7%94%A8Emoji%E8%A1%A8%E6%83%85/"/>
    <id>http://ysir.me/2017/06/08/如何在Windows10中使用Emoji表情/</id>
    <published>2017-06-08T13:09:56.000Z</published>
    <updated>2017-09-05T13:52:44.701Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<br><a href="https://www.maketecheasier.com/use-emojis-in-windows10/" target="_blank" rel="external">如何在Windows10中使用Emoji表情</a></p><h2 id="使用触摸键盘"><a href="#使用触摸键盘" class="headerlink" title="使用触摸键盘"></a>使用触摸键盘</h2><p>使用 Emoji 表情的一种方式是使用触摸键盘。</p><h3 id="找到触摸键盘"><a href="#找到触摸键盘" class="headerlink" title="找到触摸键盘"></a>找到触摸键盘</h3><p>右击任务栏，然后点击“显示触摸键盘按钮”<br><img src="https://i.loli.net/2017/09/05/59aeab2cc880c.jpg" alt=""></p><p>注意，键盘图标会显示在你的托盘区，然后点击这个图标<br><img src="https://i.loli.net/2017/09/05/59aeab2cae998.jpg" alt=""></p><p>这时，触摸键盘会从屏幕底部弹出，然后在键盘右下角切换成英文输入法，在键盘中找到笑脸图标。点击笑脸图标来到 Emoji 菜单，你会看到 Windows 10 的所有 Emoji 表情。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文链接：&lt;br&gt;&lt;a href=&quot;https://www.maketecheasier.com/use-emojis-in-windows10/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;如何在Windows10中使用Emoji表情&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="翻译" scheme="http://ysir.me/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="翻译" scheme="http://ysir.me/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="maketecheasier" scheme="http://ysir.me/tags/maketecheasier/"/>
    
      <category term="Emoji" scheme="http://ysir.me/tags/Emoji/"/>
    
      <category term="Win10" scheme="http://ysir.me/tags/Win10/"/>
    
  </entry>
  
  <entry>
    <title>Cannot find autoconf</title>
    <link href="http://ysir.me/2016/04/15/Cannot-find-autoconf/"/>
    <id>http://ysir.me/2016/04/15/Cannot-find-autoconf/</id>
    <published>2016-04-15T05:52:35.000Z</published>
    <updated>2017-06-04T11:08:14.940Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Cannotfind autoconf. Please check your autoconf installation and the<br>$PHP_AUTOCONFenvironment variable. Then, rerun this script.</p></blockquote><p>解决方案，终端输入命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install m4</div><div class="line">sudo apt-get isntall autoconf</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Cannotfind autoconf. Please check your autoconf installation and the&lt;br&gt;$PHP_AUTOCONFenvironment variable. Then, rerun this 
      
    
    </summary>
    
      <category term="Linux" scheme="http://ysir.me/categories/Linux/"/>
    
    
      <category term="问题" scheme="http://ysir.me/tags/%E9%97%AE%E9%A2%98/"/>
    
      <category term="编译" scheme="http://ysir.me/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Xcode: No matching provisioning profiles found</title>
    <link href="http://ysir.me/2016/02/18/Xcode-No-matching-provisioning-profiles-found/"/>
    <id>http://ysir.me/2016/02/18/Xcode-No-matching-provisioning-profiles-found/</id>
    <published>2016-02-18T07:38:24.000Z</published>
    <updated>2017-06-04T11:13:51.711Z</updated>
    
    <content type="html"><![CDATA[<ol><li>右键 xcodeproj 文件 -&gt; 显示包内容。</li><li>打开 pbxproj 文件。</li><li>删除所有的 PROVISIONING_PROFILE = “uuid” 整行，重启项目。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://stackoverflow.com/questions/18475964/xcode5-no-matching-provisioning-profiles-found-issue-but-good-at-xcode4" target="_blank" rel="external">Xcode5 “No matching provisioning profiles found issue” (but good at xcode4)</a><br><a href="http://stackoverflow.com/questions/34346436/xcode-7-2-no-matching-provisioning-profiles-found" target="_blank" rel="external">Xcode 7.2 no matching provisioning profiles found</a><br><a href="http://blog.csdn.net/cuibo1123/article/details/39432411" target="_blank" rel="external">xcode6更新证书错误：No matching provisioning profiles found 解决方案</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;右键 xcodeproj 文件 -&amp;gt; 显示包内容。&lt;/li&gt;
&lt;li&gt;打开 pbxproj 文件。&lt;/li&gt;
&lt;li&gt;删除所有的 PROVISIONING_PROFILE = “uuid” 整行，重启项目。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;参考&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Mac" scheme="http://ysir.me/categories/Mac/"/>
    
    
      <category term="问题" scheme="http://ysir.me/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Missing iOS Distribution signing identity for</title>
    <link href="http://ysir.me/2016/02/18/Missing-iOS-Distribution-signing-identity-for/"/>
    <id>http://ysir.me/2016/02/18/Missing-iOS-Distribution-signing-identity-for/</id>
    <published>2016-02-18T06:36:41.000Z</published>
    <updated>2017-06-04T11:11:04.156Z</updated>
    
    <content type="html"><![CDATA[<ol><li>下载 <a href="https://developer.apple.com/certificationauthority/AppleWWDRCA.cer" target="_blank" rel="external">https://developer.apple.com/certificationauthority/AppleWWDRCA.cer</a></li><li>双击安装到钥匙串。</li><li>钥匙串 -&gt; 显示 -&gt; 显示已过期的证书。</li><li>钥匙串区域选择系统标签。</li><li>删除 Apple Worldwide Developer Relations Certificate Authority certificates。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://stackoverflow.com/questions/32821189/xcode-7-error-missing-ios-distribution-signing-identity-for" target="_blank" rel="external">Xcode 7 error: “Missing iOS Distribution signing identity for …”</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;下载 &lt;a href=&quot;https://developer.apple.com/certificationauthority/AppleWWDRCA.cer&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.ap
      
    
    </summary>
    
      <category term="iOS" scheme="http://ysir.me/categories/iOS/"/>
    
    
      <category term="问题" scheme="http://ysir.me/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Windows下error LNK2019: 无法解析的外部符号 __imp__select@20</title>
    <link href="http://ysir.me/2015/11/18/Windows%E4%B8%8Berror-LNK2019-%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E7%9A%84%E5%A4%96%E9%83%A8%E7%AC%A6%E5%8F%B7-imp-select-20/"/>
    <id>http://ysir.me/2015/11/18/Windows下error-LNK2019-无法解析的外部符号-imp-select-20/</id>
    <published>2015-11-18T05:16:18.000Z</published>
    <updated>2017-06-04T11:05:52.671Z</updated>
    
    <content type="html"><![CDATA[<p>缺少Ws2_32.lib，Wldap32.lib这两个库，直接搜索这两个库放到程序目录下即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;缺少Ws2_32.lib，Wldap32.lib这两个库，直接搜索这两个库放到程序目录下即可。&lt;/p&gt;

      
    
    </summary>
    
      <category term="C/C++" scheme="http://ysir.me/categories/C-C/"/>
    
    
      <category term="问题" scheme="http://ysir.me/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C之property属性分析</title>
    <link href="http://ysir.me/2015/09/23/Objective-C%E4%B9%8Bproperty%E5%B1%9E%E6%80%A7%E5%88%86%E6%9E%90/"/>
    <id>http://ysir.me/2015/09/23/Objective-C之property属性分析/</id>
    <published>2015-09-23T14:48:51.000Z</published>
    <updated>2017-06-04T11:04:25.857Z</updated>
    
    <content type="html"><![CDATA[<p>@property和@synthesize用来生成属性的set和get方法</p><p>格式：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span>(属性列表) 类型 属性名</div><div class="line"><span class="keyword">@synthesize</span> 属性名</div></pre></td></tr></table></figure><p>属性列表包括：strong(retain), copy, weak(assign), atomic, nonatomic, readonly, readwrite, getter=name, setter=name</p><p>strong和weak是引入ARC时加入的关键字</p><p>属性列表与关键字的对应关系</p><table><thead><tr><th>属性值</th><th>关键字</th><th>所有权</th></tr></thead><tbody><tr><td>strong, copy, retain</td><td>__strong</td><td>有</td></tr><tr><td>weak</td><td>__weak</td><td>无</td></tr><tr><td>assign, unsafe_unretained</td><td>__unsafe_unretained</td><td>无</td></tr></tbody></table><p>属性默认为assign（如果属性是NSObject（或者它子类的）的对象时，默认为strong）, readwrite, atomic</p><p>@property int i;等价于@property(assign, readwrite, atomic) int i;<br>@property NSString <em>s;等价于@property(strong, readwrite, atomic) NSString </em>s;</p><p>strong和retain类似，对所指的对象引用计数加1（如果所指对象是可变对象的话）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableString</span> *str = [[<span class="built_in">NSMutableString</span> alloc] initWithUTF8String:<span class="string">"mutablestring"</span>];</div><div class="line">member.strong = str; <span class="comment">// 头文件定义@property(strong) NSString *strong; strong和str指向同一个内存地址</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, <span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)(str))); <span class="comment">// 输出2（NSLog可能对引用计数结果有影响，所以在这之前不要使用类似NSLog(@"%@", member.strong);语句，最好在查看引用计数时先屏蔽掉其他NSLog）</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, member.strong); <span class="comment">// 输出mutablestring</span></div><div class="line">[str deleteCharactersInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">7</span>)];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, member.strong); <span class="comment">// 输出string</span></div></pre></td></tr></table></figure><p>我改变的是str的内容，但是strong却被同时改变了，这是因为strong和str指向的是同一块内存（可以在Xcode中调试View Memory of “<em>_strong”和View Memory of “</em>str”可以看到它们的Address是一致的），该内存的引用计数为2，所以改变s的内容实际上就改变了strong的内容</p><p>另外如果用一个strong指针来指向不可变对象str，那么str的引用计数不会加1</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *str = <span class="string">@"string"</span>; <span class="comment">// @"string"存放在内存的常量区（不可变），生命周期为整个程序的生命周期，引用计数为一个很大的数，不会被改变</span></div><div class="line"><span class="built_in">NSString</span> *__<span class="keyword">strong</span> s = str; <span class="comment">// 试图使str的引用计数加1</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, <span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)(str))); <span class="comment">// 引用计数不变</span></div></pre></td></tr></table></figure><p>那么如果我们不想让strong和str指向一个地方，这时copy就派上用场了，copy和strong类似，但是它不影响所指向的对象的引用计数，如果str指向的对象是可变的，那么copy会创建一个所指向对象的不可变副本（你不能修改copy指向的地址的内容，即使这个copy是NSMultableString，[str copy]同理），它们不指向同一个内存地址</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableString</span> *str = [[<span class="built_in">NSMutableString</span> alloc] initWithUTF8String:<span class="string">"mutablestring"</span>]; <span class="comment">// 堆中分配内存</span></div><div class="line">member.cp = str; <span class="comment">// 头文件定义@property(copy) NSString *cp; cp指向str的副本，cp和str指向不同地址</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, member.cp); <span class="comment">// 输出mutablestring</span></div><div class="line">[str deleteCharactersInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">7</span>)];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, member.cp); <span class="comment">// 然并卵，cp没有改变，输出mutablestring</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p %p"</span>, str, member.cp); <span class="comment">// 地址不同</span></div><div class="line"></div><div class="line">member.mscp = str; <span class="comment">// 头文件定义@property(copy) NSMutableString *mscp</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p %p"</span>, str, member.mscp); <span class="comment">// 地址不同</span></div><div class="line">[member.mscp deleteCharactersInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">7</span>)]; <span class="comment">// mscp指向不可变的副本，即使它是NSMutableString，也不能修改其指向的内容。运行时报错Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: 'Attempt to mutate immutable object with deleteCharactersInRange:'</span></div></pre></td></tr></table></figure><p>如果str指向的对象不可变，结果又会不一样</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"string"</span>]; <span class="comment">// str虽然在堆中分配内存，但是@"string"实际上是不能被改变的，这个对象会被添加到自动释放池</span></div><div class="line">member.cp = str;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, <span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)(str))); <span class="comment">// 引用计数为一个很大值</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p %p"</span>, str, member.cp); <span class="comment">// cp并没有分配新的空间，因为str指向的内存地址不可改变（也就是说@"string"这个值无法改变，不能变成@"abc"之类的），所以cp和str指向了同一个地址</span></div></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *str = <span class="string">@"string"</span>; <span class="comment">// @"string"存放在内存的常量区（不可变），生命周期为整个程序的生命周期，引用计数为一个很大的数，不会被改变</span></div><div class="line">member.cp = str;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, <span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)(str))); <span class="comment">// 一个非常大的引用计数</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%p %p"</span>, str, member.cp); <span class="comment">// cp并没有分配新的空间，因为str指向的内存地址不可改变（也就是说@"string"这个值无法改变，不能变成@"abc"之类的），所以cp和str指向了同一个地址</span></div></pre></td></tr></table></figure><p>weak和assign不会对所指的对象引用计数加1（还是指向的同一个内存地址），它们的区别就是当weak指向的内存区域被释放时，weak指针会被赋值为nil，而如果用的是assign，不会被赋值为nil，再去使用这个指针时，运行时会报错</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *str= [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"%s"</span>, <span class="string">"Name:zyu"</span>];</div><div class="line">member.weak = str; <span class="comment">// 头文件定义@property(weak) NSString *weak; weak和str指向同一个内存地址</span></div><div class="line">str= <span class="literal">nil</span>; <span class="comment">// str空间释放时，weak被赋值成nil</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, member.weak); <span class="comment">// 输出(null)</span></div></pre></td></tr></table></figure><p>等价于</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"%s"</span>, <span class="string">"Name:zyu"</span>];</div><div class="line"><span class="built_in">NSString</span> * __<span class="keyword">weak</span> _<span class="keyword">weak</span> = str; <span class="comment">// 还可以用关键字来定义weak属性</span></div><div class="line">str = <span class="literal">nil</span>;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, _<span class="keyword">weak</span>); <span class="comment">// 输出(null)</span></div></pre></td></tr></table></figure><p>@当我把”Name:zyu”改成”zyu”时，NSLog输出的结果不是(null)，不知道是不是Xcode的bug。(￣▽￣)</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *str= [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"%s"</span>, <span class="string">"Name:zyu"</span>];</div><div class="line">member.assign= str; <span class="comment">// 头文件定义@property(assign) NSString *assign; assign和str指向同一个内存地址</span></div><div class="line">str= <span class="literal">nil</span>; <span class="comment">// str空间释放时，assign不会被赋值成nil</span></div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, member.assign); <span class="comment">// 运行时报错EXC_BAD_ACCESS，有时候又不报错，没有任何输出(╯°□°）╯︵ ┻━┻</span></div></pre></td></tr></table></figure><p><a href="http://www.devtalking.com/articles/you-should-to-know-property/" target="_blank" rel="external">Objective-C中的@property</a><br><a href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="external">Transitioning to ARC Release Notes</a><br><a href="http://www.cnblogs.com/andyque/archive/2011/08/03/2125728.html" target="_blank" rel="external">Objective-c的@property 详解</a><br><a href="http://www.devm.cn/2015/07/16/the-proper-use-of-property-keywords.html" target="_blank" rel="external">如何正确使用property里面的strong,weak等关健字</a><br><a href="http://blog.csdn.net/jymn_chen/article/details/18887841" target="_blank" rel="external">复制对象（一）copy和mutableCopy方法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@property和@synthesize用来生成属性的set和get方法&lt;/p&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;
      
    
    </summary>
    
      <category term="Objective-C" scheme="http://ysir.me/categories/Objective-C/"/>
    
    
      <category term="Objective-C" scheme="http://ysir.me/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>error LNK2019: 无法解析的外部符号 __imp____iob_func</title>
    <link href="http://ysir.me/2015/09/23/error-LNK2019-%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E7%9A%84%E5%A4%96%E9%83%A8%E7%AC%A6%E5%8F%B7-imp-iob-func/"/>
    <id>http://ysir.me/2015/09/23/error-LNK2019-无法解析的外部符号-imp-iob-func/</id>
    <published>2015-09-23T10:06:24.000Z</published>
    <updated>2017-06-04T10:56:31.090Z</updated>
    
    <content type="html"><![CDATA[<p>在VS2015中使用静态库时编译出错</p><pre><code>1&gt;libcurl_md.lib(cookie.obj) : error LNK2019: 无法解析的外部符号 __imp____iob_func，该符号在函数 _Curl_cookie_init 中被引用1&gt;libcurl_md.lib(url.obj) : error LNK2001: 无法解析的外部符号 __imp____iob_func1&gt;libcurl_md.lib(mprintf.obj) : error LNK2001: 无法解析的外部符号 __imp____iob_func1&gt;libcurl_md.lib(formdata.obj) : error LNK2001: 无法解析的外部符号 __imp____iob_func1&gt;libcurl_md.lib(ftp.obj) : error LNK2001: 无法解析的外部符号 __imp__sscanf1&gt;libcurl_md.lib(rtsp.obj) : error LNK2001: 无法解析的外部符号 __imp__sscanf1&gt;libcurl_md.lib(socks.obj) : error LNK2001: 无法解析的外部符号 __imp__sscanf1&gt;libcurl_md.lib(http_proxy.obj) : error LNK2001: 无法解析的外部符号 __imp__sscanf1&gt;libcurl_md.lib(transfer.obj) : error LNK2001: 无法解析的外部符号 __imp__sscanf1&gt;libcurl_md.lib(parsedate.obj) : error LNK2001: 无法解析的外部符号 __imp__sscanf1&gt;libcurl_md.lib(imap.obj) : error LNK2001: 无法解析的外部符号 __imp__sscanf1&gt;libcurl_md.lib(telnet.obj) : error LNK2001: 无法解析的外部符号 __imp__sscanf1&gt;libcurl_md.lib(cookie.obj) : error LNK2001: 无法解析的外部符号 __imp__sscanf1&gt;libcurl_md.lib(hostip.obj) : error LNK2001: 无法解析的外部符号 __imp__sscanf1&gt;libcurl_md.lib(url.obj) : error LNK2001: 无法解析的外部符号 __imp__sscanf1&gt;libcurl_md.lib(http.obj) : error LNK2001: 无法解析的外部符号 __imp__sscanf1&gt;libcurl_md.lib(mprintf.obj) : error LNK2019: 无法解析的外部符号 __imp__sprintf，该符号在函数 _dprintf_formatf 中被引用1&gt;libcurl_md.lib(idn_win32.obj) : error LNK2019: 无法解析的外部符号 __imp__wprintf，该符号在函数 _curl_win32_ascii_to_idn 中被引用1&gt;C:\Users\zyu\Documents\Visual Studio 2015\Projects\ConsoleApplication1\Debug\ConsoleApplication1.exe : fatal error LNK1120: 4 个无法解析的外部命令</code></pre><p>原因是我这个libcurl_md.lib的库是在VS2013环境下编出来的，直接用到VS2015中出现问题</p><p>解决方案：把lib重新编译成VS2015版本，再使用OK</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在VS2015中使用静态库时编译出错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1&amp;gt;libcurl_md.lib(cookie.obj) : error LNK2019: 无法解析的外部符号 __imp____iob_func，该符号在函数 _Curl_cookie_init 中
      
    
    </summary>
    
      <category term="C/C++" scheme="http://ysir.me/categories/C-C/"/>
    
    
      <category term="问题" scheme="http://ysir.me/tags/%E9%97%AE%E9%A2%98/"/>
    
      <category term="编译" scheme="http://ysir.me/tags/%E7%BC%96%E8%AF%91/"/>
    
      <category term="库" scheme="http://ysir.me/tags/%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C数据类型输出格式及隐式转换详解</title>
    <link href="http://ysir.me/2015/09/21/Objective-C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F%E5%8F%8A%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E8%AF%A6%E8%A7%A3/"/>
    <id>http://ysir.me/2015/09/21/Objective-C数据类型输出格式及隐式转换详解/</id>
    <published>2015-09-21T15:39:50.000Z</published>
    <updated>2017-06-04T10:55:02.898Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单数据类型和输出格式符"><a href="#简单数据类型和输出格式符" class="headerlink" title="简单数据类型和输出格式符"></a>简单数据类型和输出格式符</h2><table><thead><tr><th>类型说明符</th><th>格式符</th></tr></thead><tbody><tr><td>char</td><td>%c</td></tr><tr><td>short int</td><td>%hd, %hi, %hx, %ho</td></tr><tr><td>unsigned short int</td><td>%hu, %hx, %ho</td></tr><tr><td>int</td><td>%d, %i, %x, %o</td></tr><tr><td>unsigned int</td><td>%u, %x, %o</td></tr><tr><td>long int</td><td>%ld, %li, %lx, %lo</td></tr><tr><td>unsigned long int</td><td>%lu, %lx, %lo</td></tr><tr><td>long long int</td><td>%lld, %lli, %llx, %llo</td></tr><tr><td>unsigned long long int</td><td>%llu, %llx, %llo</td></tr><tr><td>float</td><td>%f, %e, %g, %a</td></tr><tr><td>double</td><td>%f, %e, %g, %a</td></tr><tr><td>long double</td><td>%Lf, %Le, %Lg</td></tr><tr><td>*</td><td>%p</td></tr></tbody></table><h2 id="数据类型的隐式转换"><a href="#数据类型的隐式转换" class="headerlink" title="数据类型的隐式转换"></a>数据类型的隐式转换</h2><p>编译器按下面的顺序进行自动类型转换：</p><ol><li>如果其中一个数是long double类型的，那么另一个操作数被转换为long double类型，计算的结果也是long double类型。</li><li>如果一个数是double类型的，那么另一个操作数被转换为double类型，计算的结果也是double类型。</li><li>如果一个数是float类型的，那么另一个操作数被转换为float类型，计算的结果也是float类型。</li><li>如果一个数是Bool、char、short int、bit field、枚举类型的，则全部转换为int类型，计算的结果也是int类型。</li><li>如果一个数是long long int类型的，那么另一个操作数被转换为long long int类型，计算的结果也是long long int类型。</li><li>如果一个数是long int类型的，那么另一个操作数被转换为long int类型，计算的结果也是long int类型。</li></ol><p>整型数运算遵循一个规则：字节小的往字节大的转，有符号的往无符号的转</p><p>所有比int型小的数据类型（包括char,unsigned char,short,unsigned short）转换为int型再参与运算。如果转换后的数据会超出int型所能表示的范围的话，则转换为unsigned int型。</p><p>一般来说这样提升，从小到大：比int小的 -&gt; int -&gt; unsigned int -&gt; long -&gt; unsigned long</p><p>eg：（测试环境Mac）</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> c = <span class="string">'c'</span>;</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> b = <span class="number">1</span>;</div><div class="line">b + c; <span class="comment">// 结果为int类型</span></div><div class="line"></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> a;</div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> b;</div><div class="line">a+b; <span class="comment">// 结果为int类型</span></div><div class="line"></div><div class="line"><span class="keyword">enum</span>会跟据最大值来决定类型，一般来说为<span class="keyword">int</span>型，如果超出<span class="keyword">int</span>型所能表示的范围，则用比<span class="keyword">int</span>型大的最小类型来表示（<span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">long</span> 或者<span class="keyword">unsigned</span> <span class="keyword">long</span>）</div><div class="line"><span class="keyword">enum</span> e &#123;MON = <span class="number">12345678987654321</span>&#125;;</div><div class="line"><span class="keyword">enum</span> e eg = MON; <span class="comment">// 此时eg为unsigned long类型</span></div><div class="line"><span class="keyword">int</span> i;</div><div class="line">eg + i; <span class="comment">// 结果为unsigned long类型</span></div></pre></td></tr></table></figure><p>如果表达式中混有unsigned short和int型时，如果int型数据可以表示所有的unsigned short型的话，则将unsigned short类型的数据转换为int型，否则，unsigned short类型及int型都转换为unsigned int类型。unsigned int和long同理。</p><p>几个常用的数据类型转换</p><pre><code>double — float|long|unsigned|int — char,short</code></pre><p><a href="http://blog.sina.com.cn/s/blog_590be5290100htvu.html" target="_blank" rel="external">signed和unsigned之间</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简单数据类型和输出格式符&quot;&gt;&lt;a href=&quot;#简单数据类型和输出格式符&quot; class=&quot;headerlink&quot; title=&quot;简单数据类型和输出格式符&quot;&gt;&lt;/a&gt;简单数据类型和输出格式符&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型说明符&lt;/t
      
    
    </summary>
    
      <category term="Objective-C" scheme="http://ysir.me/categories/Objective-C/"/>
    
    
      <category term="Objective-C" scheme="http://ysir.me/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>初识Git</title>
    <link href="http://ysir.me/2015/09/17/%E5%88%9D%E8%AF%86Git/"/>
    <id>http://ysir.me/2015/09/17/初识Git/</id>
    <published>2015-09-17T08:54:09.000Z</published>
    <updated>2017-06-04T10:50:29.170Z</updated>
    
    <content type="html"><![CDATA[<p>对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。已提交表示该文件已经被安全地保存在本地数据库中了；已修改表示修改了某个文件，但还没有提交保存；已暂存表示把已修改的文件放在下次提交时要保存的清单中。</p><p>由此我们看到 Git 管理项目时，文件流转的三个工作区域：Git 的工作目录，暂存区域，以及本地仓库。</p><p>基本的 Git 工作流程如下：</p><ol><li>在工作目录中修改某些文件。</li><li>对修改后的文件进行快照，然后保存到暂存区域。</li><li>提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中。</li></ol><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>一般在新的系统上，我们都需要先配置下自己的 Git 工作环境。配置工作只需一次，以后升级时还会沿用现在的配置。当然，如果需要，你随时可以用相同的命令修改已有的配置。</p><p>Git 提供了一个叫做 git config 的工具（译注：实际是 git-config 命令，只不过可以通过 git 加一个名字来呼叫此命令。），专门用来配置或读取相应的工作环境变量。而正是由这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：</p><ul><li>/etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 –system 选项，读写的就是这个文件。</li><li>~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 –global 选项，读写的就是这个文件。</li><li>当前项目的 git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。</li></ul><p>在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:\Documents and Settings\$USER。此外，Git 还会尝试找寻 /etc/gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。</p><p>用户信息<br>第一个要配置的是你个人的用户名称和电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global user.name <span class="string">"Jon Snow"</span></div><div class="line">git config --global user.email game@thrones.com</div></pre></td></tr></table></figure><p>可以通过git help查看帮助</p><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>要对现有的某个项目开始用 Git 管理，只需到此项目所在的目录，执行：<br><code>git init</code></p><p>初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。不过目前，仅仅是按照既有的结构框架初始化好了里边所有的文件和目录，但我们还没有开始跟踪管理项目中的任何一个文件。</p><p>git add 命令告诉 Git 开始对这些文件进行跟踪</p><p>如果要从远程仓库克隆一份，比如从github网站中弄一份代码下来，执行<br><code>git clone https://github.com/forzxy/xxx.git</code></p><p>这会在当前目录下创建一个名为xxx的目录，现在我们手上已经有了一个真实项目的 Git 仓库，并从这个仓库中取出了所有文件的工作拷贝。</p><p>执行<code>git status</code>确定哪些文件当前处于什么状态（未追踪、已修改但是未缓存、已缓存等）。</p><p>现在在当前目录添加一个新文件test.txt，执行<code>git status</code>，显示</p><pre><code>Untracked files:(use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)test.txt</code></pre><p>说明test.txt还没有被加入版本管理</p><p>执行<code>git add test.txt</code>然后再<code>git status</code></p><pre><code>Changes to be committed:(use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)new file: test.txt</code></pre><p>说明test.txt已经加入了版本管理，处于已暂存（staged）状态<br>同理修改文件内容后，也需要执行git add使文件加入暂存区</p><p>现在修改一个文件<br>执行<code>git diff</code>来查看尚未暂存的文件更新了哪些部分，此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。</p><p>若要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用 <code>git diff --cached</code>（<code>git diff --staged</code>）</p><p><code>git checkout -- filename</code> 命令表示取消对文件的修改</p><p>移除文件<br>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p><p>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f（译注：即 force 的首字母），以防误删除文件后丢失修改的内容。</p><p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。换句话说，仅是从跟踪清单中删除。比如一些大型日志文件或者一堆 .a 编译文件，</p><p>不小心纳入仓库后，要移除跟踪但不删除文件，以便稍后在 .gitignore 文件中补上，用 –cached 选项即可。</p><p>移动文件<br><code>git mv</code> 就相当于运行了下面三条命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ mv README.txt README</div><div class="line">$ git rm README.txt</div><div class="line">$ git add README</div></pre></td></tr></table></figure><p>提交更改<br>一切就绪以后使用<code>git commit</code>来提交暂存区内容，这种方式会启动文本编辑器以便输入本次提交的说明。</p><p>如果觉得每次修改后还要使用<code>git add</code>来加入暂存区很繁琐的话，可以使用<code>git commit -a</code>，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤。</p><p>修改最后一次提交<br>有时候我们提交完了才发现漏掉了几个文件没有加（忘记加入暂存区），或者提交信息写错了。可以执行<code>git commit --amend</code>来修改上一次提交</p><p>此命令将使用当前的暂存区域快照提交。如果上一次提交完没有作任何改动，直接运行此命令的话，相当于重新编辑提交说明。</p><p>查看历史<br><code>git log</code>查看提交历史</p><p>-p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新</p><p>远程仓库<br><code>git remote</code>列出每个远程库的简短名字，在克隆完某个项目后，至少可以看到一个名为 origin 的远程库，Git 默认使用这个名字来标识你所克隆的原始仓库。</p><pre><code>git remote -v显示对应的克隆地址git remote show [remote-name] 查看某个远程仓库的详细信息git remote add [shortname] [url]：添加远程仓库git remote rename 修改某个远程仓库在本地的简称git remote rm 移除对应的远端仓库</code></pre><p>从远程仓库抓取数据<br><code>git fetch origin</code>：抓取远程仓库有的，本地没有的信息，fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并。</p><p><code>git pull</code>：抓取数据并自动合并。</p><p>推送到远程仓库<br><code>git push [remote-name] [branch-name]</code>将本地仓库中branch-name分支的数据推送到远程仓库remote-name</p><p><a href="http://git.oschina.net/progit/index.html" target="_blank" rel="external">Pro Git（中文版）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。已提交表示该文件已经被安全地保存在本地数据库中了；已修改表示修改了某个文件，但还没有提交保存；已暂存表示把已修改的文件放在下次提交时要保存的清单
      
    
    </summary>
    
      <category term="Git" scheme="http://ysir.me/categories/Git/"/>
    
    
      <category term="Git" scheme="http://ysir.me/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Qt动态库的生成和使用</title>
    <link href="http://ysir.me/2015/09/17/Qt%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E7%94%9F%E6%88%90%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://ysir.me/2015/09/17/Qt动态库的生成和使用/</id>
    <published>2015-09-16T16:18:47.000Z</published>
    <updated>2017-06-04T10:42:35.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编译成动态库"><a href="#编译成动态库" class="headerlink" title="编译成动态库"></a>编译成动态库</h2><p>打开工程文件.pro</p><pre><code>TEMPLATE = libTARGET = configwifiSOURCES删除main.cpp</code></pre><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">make clean</div><div class="line">make</div></pre></td></tr></table></figure><p>生成.so文件</p><p><code>armv6z-mediatek451_001_vfp-linux-gnueabi-strip libconfigwifi.so*</code><br>缩小文件大小</p><h2 id="调用这个动态库"><a href="#调用这个动态库" class="headerlink" title="调用这个动态库"></a>调用这个动态库</h2><p>新建工程，用上面不用的main.cpp</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">qmake -project</div><div class="line">qmake</div></pre></td></tr></table></figure><p>修改.pro</p><pre><code>TEMPLATE = appLIBS += -L/home/zhang/normal -lconfigwifiHEADERS += widget.h(main.cpp里用到的)SOURCES += main.cpp</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;编译成动态库&quot;&gt;&lt;a href=&quot;#编译成动态库&quot; class=&quot;headerlink&quot; title=&quot;编译成动态库&quot;&gt;&lt;/a&gt;编译成动态库&lt;/h2&gt;&lt;p&gt;打开工程文件.pro&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TEMPLATE = lib
TARGET = conf
      
    
    </summary>
    
      <category term="Qt" scheme="http://ysir.me/categories/Qt/"/>
    
    
      <category term="Qt" scheme="http://ysir.me/tags/Qt/"/>
    
      <category term="动态库" scheme="http://ysir.me/tags/%E5%8A%A8%E6%80%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Linux开机显示命令行</title>
    <link href="http://ysir.me/2015/09/16/Linux%E5%BC%80%E6%9C%BA%E6%98%BE%E7%A4%BA%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    <id>http://ysir.me/2015/09/16/Linux开机显示命令行/</id>
    <published>2015-09-16T15:58:41.000Z</published>
    <updated>2017-06-04T10:38:09.611Z</updated>
    
    <content type="html"><![CDATA[<p>Linux登录模式中，主要分为两种，一种是仅有纯文本界面（运行等级run level 3）的登录环境，另一种则是图形界面（运行等级run level 5）</p><p>以Ubuntu 12.04为例<br><code>sudo gedit /etc/default/grub</code></p><p>找到这一行</p><blockquote><p>GRUB_CMDLINE_LINUX_DEFAULT=”quiet splash”</p></blockquote><p>改成</p><blockquote><p>GRUB_CMDLINE_LINUX_DEFAULT=”quiet splash text”</p></blockquote><p>再输入命令：<br><code>sudo update-grub</code></p><p>开机后就自动进入tty1了。</p><p>进入图形界面sudo start lightdm 或者输入 startx</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux登录模式中，主要分为两种，一种是仅有纯文本界面（运行等级run level 3）的登录环境，另一种则是图形界面（运行等级run level 5）&lt;/p&gt;
&lt;p&gt;以Ubuntu 12.04为例&lt;br&gt;&lt;code&gt;sudo gedit /etc/default/gru
      
    
    </summary>
    
      <category term="Linux" scheme="http://ysir.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://ysir.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux删除乱码文件名</title>
    <link href="http://ysir.me/2015/09/16/Linux%E5%88%A0%E9%99%A4%E4%B9%B1%E7%A0%81%E6%96%87%E4%BB%B6%E5%90%8D/"/>
    <id>http://ysir.me/2015/09/16/Linux删除乱码文件名/</id>
    <published>2015-09-16T15:49:04.000Z</published>
    <updated>2017-06-04T10:36:23.678Z</updated>
    
    <content type="html"><![CDATA[<p>每个文件都有一个i节点号，通过ls -i获取</p><pre><code>1644970 a.out1645007 main.c</code></pre><p>使用find命令将文件名传递给rm命令来删除<br><code>find ./ -inum 12345 -print -exec rm {} -rf /;</code><br>12345是节点号 /;前面的空格不能少</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;每个文件都有一个i节点号，通过ls -i获取&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1644970 a.out
1645007 main.c
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用find命令将文件名传递给rm命令来删除&lt;br&gt;&lt;code&gt;find ./ -inum 12345 -p
      
    
    </summary>
    
      <category term="Linux" scheme="http://ysir.me/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://ysir.me/tags/Linux/"/>
    
      <category term="文件" scheme="http://ysir.me/tags/%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>终端程序切换前后台命令</title>
    <link href="http://ysir.me/2015/09/16/%E7%BB%88%E7%AB%AF%E7%A8%8B%E5%BA%8F%E5%88%87%E6%8D%A2%E5%89%8D%E5%90%8E%E5%8F%B0%E5%91%BD%E4%BB%A4/"/>
    <id>http://ysir.me/2015/09/16/终端程序切换前后台命令/</id>
    <published>2015-09-16T15:40:26.000Z</published>
    <updated>2017-06-04T10:34:46.173Z</updated>
    
    <content type="html"><![CDATA[<p>首先终端下执行vim test.txt打开vim编辑器</p><p>按下ctrl＋z挂起程序</p><p>终端显示：</p><pre><code>[1]+  Stopped                 vim test.txt</code></pre><p>[1]表示作业号</p><p>然后我们让这个程序后台执行，输入bg 1</p><p>终端显示：</p><pre><code>[1]+ vim test.txt &amp;[1]+  Stopped                 vim test.txt</code></pre><p>输入jobs查看后台执行的程序</p><pre><code>[1]+  Stopped                 vim test.txt</code></pre><p>再输入fg 1，就可以把程序调回前台运行了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先终端下执行vim test.txt打开vim编辑器&lt;/p&gt;
&lt;p&gt;按下ctrl＋z挂起程序&lt;/p&gt;
&lt;p&gt;终端显示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[1]+  Stopped                 vim test.txt
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;[1
      
    
    </summary>
    
      <category term="Linux" scheme="http://ysir.me/categories/Linux/"/>
    
    
      <category term="命令" scheme="http://ysir.me/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>man命令详解</title>
    <link href="http://ysir.me/2015/09/16/man%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
    <id>http://ysir.me/2015/09/16/man命令详解/</id>
    <published>2015-09-16T15:27:53.000Z</published>
    <updated>2017-06-04T10:32:24.579Z</updated>
    
    <content type="html"><![CDATA[<p><code>man</code><br>manual手册，通常放在/usr/share/man，可以修改/etc/man.config(man.conf或manpath.conf)来改善这个目录</p><p>例如<br><code>man date</code></p><pre><code>DATE(1)                   BSD General Commands Manual                  DATE(1)DATE(1) 中数字的含义1 用户在shell环境中可以操作的命令或可执行文件2 系统内核可调用的函数与工具等3 一些常用函数与函数库，大部分为C函数库4 设备文件的说明，通常在/dev下的文件5 配置文件或者是某些文件的格式6 游戏7 惯例与协议等，例如linux文件系统、网络协议、ASCII code等说明8 系统管理员可用的管理命令9 跟kernel有关的文件NAME    date -- display or set date and time命令的完整全名及简单用途说明SYNOPSIS    date [-ju] [-rseconds] [-v [+|-]val[ymwdHMS]]... [+output_fmt]    date [-jnu] [[[mm]dd]HH]MM[[cc]yy][.ss]    date [-jnu]-finput_fmtnew_date [+output_fmt]    date [-ddst] [-tminutes_west]命令的基本语法DESCRIPTION    When invoked without arguments, thedate utility displays the current    date and time.  Otherwise, depending on the options specified,date will    set the date and time or print it in a user-defined way.    Thedate utility displays the date and time read from the kernel clock.    When used to set the date and time, both the kernel clock and the hard-    ware clock are updated.    Only the superuser may set the date, and if the system securelevel (see    securelevel(8)) is greater than 1, the time may not be changed by more    than 1 second.    The options are as follows:    -ddst  Set the kernel&apos;s value for daylight saving time.  Ifdst is non-            zero, future calls to gettimeofday(2) will return a non-zero for            tz_dsttime.详细说明用法，-d为短参数名称，--date为完整参数名（Linux下和Mac有不同）</code></pre><p>man page大致分为下面几个部分</p><pre><code>NAME            简短的命令、数据名称说明SYNOPSIS       简短的命令执行语法简介DESCRIPTION    较为完整的说明OPTIONS        针对SYNOPSIS部分中，有列举的所有可用的选项说明COMMANDS     当这个程序在执行的时候，可以在此程序中执行的命令FILES            这个程序或数据所使用或参考或连接到的某些文件SEE ALSO       这个命令有关的其他说明EXAMPLE        范例BUGS            是否有相关的错误</code></pre><p>查询跟man命令有关的手册</p><p>man -f man 相当于 whatis man</p><p>只要有man关键字就将该说明列出来</p><p>man -k man 相当于 apropos man</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;man&lt;/code&gt;&lt;br&gt;manual手册，通常放在/usr/share/man，可以修改/etc/man.config(man.conf或manpath.conf)来改善这个目录&lt;/p&gt;
&lt;p&gt;例如&lt;br&gt;&lt;code&gt;man date&lt;/code&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="Linux" scheme="http://ysir.me/categories/Linux/"/>
    
    
      <category term="命令" scheme="http://ysir.me/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>ls -al每一列的意思</title>
    <link href="http://ysir.me/2015/09/16/ls-al%E6%AF%8F%E4%B8%80%E5%88%97%E7%9A%84%E6%84%8F%E6%80%9D/"/>
    <id>http://ysir.me/2015/09/16/ls-al每一列的意思/</id>
    <published>2015-09-16T15:22:07.000Z</published>
    <updated>2017-06-04T10:27:38.610Z</updated>
    
    <content type="html"><![CDATA[<p><code>ls -al</code></p><p>查看文件信息</p><p>drwx——+  9 zyu  staff    306  8 19 21:15 Pictures<br>drwxr-xr-x+  6 zyu  staff    204  3 30 22:09 Public</p><p>第一列：文件的类型与权限<br>第一个字母代表文件类型：d目录，-文件，l链接文件，b设备文件里的可供存储的接口设备，c表示设备文件里的串行端口设备，如键盘鼠标等一次性读取设备<br>接下来三个一组，第一组为文件所有者权限，第二组为同用户组的权限，第三组为其他非本用户组的权限</p><p>第二列：有多少文件名连接到此节点（i-node）<br>每个文件都会将它的权限与属性记录到文件系统的i-node中，不过我们使用的目录树却是使用文件名来记录，因此每个文件名就会连接到一个i-node，这个属性记录的就是有多少不同的文件名连接到相同的一个i-node号码</p><p>第三列：所有者账号</p><p>第四列：文件所属用户组</p><p>第五列：容量大小，默认单位B</p><p>第六列：创建或最近修改日期<br>查看完整时间 ls -l –full-time</p><p>第七列：文件名</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;ls -al&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;查看文件信息&lt;/p&gt;
&lt;p&gt;drwx——+  9 zyu  staff    306  8 19 21:15 Pictures&lt;br&gt;drwxr-xr-x+  6 zyu  staff    204  3 30 22:0
      
    
    </summary>
    
      <category term="Linux" scheme="http://ysir.me/categories/Linux/"/>
    
    
      <category term="命令" scheme="http://ysir.me/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>配置vim</title>
    <link href="http://ysir.me/2015/09/16/%E9%85%8D%E7%BD%AEvim/"/>
    <id>http://ysir.me/2015/09/16/配置vim/</id>
    <published>2015-09-16T15:16:52.000Z</published>
    <updated>2017-06-04T10:25:51.816Z</updated>
    
    <content type="html"><![CDATA[<p>vim /etc/vim/vimrc 打开vimrc</p><p>结尾加上</p><pre><code>set ts=4 ts = tabstop，缩进所使用的长度set expandtab tab转换成空格set autoindent 自动缩进set number 显示行号</code></pre><p>打开文件时跳到上一次退出的位置<br>找到Uncomment the following to have Vim jump to the last position when reopening a file取消注释掉下面的if…endif</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;vim /etc/vim/vimrc 打开vimrc&lt;/p&gt;
&lt;p&gt;结尾加上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;set ts=4 ts = tabstop，缩进所使用的长度
set expandtab tab转换成空格
set autoindent 自动缩进
set numbe
      
    
    </summary>
    
      <category term="工具" scheme="http://ysir.me/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="VIM" scheme="http://ysir.me/tags/VIM/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程相关</title>
    <link href="http://ysir.me/2015/09/16/Linux%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3/"/>
    <id>http://ysir.me/2015/09/16/Linux进程相关/</id>
    <published>2015-09-16T06:45:04.000Z</published>
    <updated>2017-06-05T17:18:53.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>我们可以通过调用fork创建一个新进程。这个系统调用复制当前进程，在进程表中创建一个新的表项，新表项中的许多属性与当前进程是相同的。新进程几乎与原进程一模一样，执行的代码也完全相同，但新进程有自己的数据空间、环境和文件描述符。fork和exec函数结合在一起使用就是创建新进程所需要的一切了。</p><p>fork之后，子进程是父进程的副本。子进程将获得父进程的数据空间、堆和栈的副本。父子进程不共享这些存储空间部分。父子进程共享正文段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</div></pre></td></tr></table></figure><p>在父进程中的fork调用返回的是新的子进程的进程号PID（这个PID并不是父进程的PID，而是新建的子进程的PID）。新进程将继续执行，就像原进程一样，不同之处在于，子进程中的fork调用返回的是0。父子进程可以通过这一点来判断究竟谁是父进程，谁是子进程。如果fork失败，它将返回-1。失败通常是因为父进程所拥有的子进程数目超过了规定的限制（CHILD_MAX），此时errno将被设为EAGAIN。如果是因为进程表里没有足够的空间用于创建新的表单或虚拟内存不足，errno变量将被设为ENOMEM。</p><p>也就是说如果fork返回-1，表示进程创建失败；返回0，表示当前进程为子进程；返回其他值表示当前进程为父进程，并且这个值是子进程的PID。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    write(STDOUT_FILENO, <span class="string">"write\n"</span>, <span class="number">6</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"before fork\n"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">pid_t</span> pid = fork();</div><div class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)</div><div class="line">    &#123;</div><div class="line">        perror(<span class="string">"fork error"</span>);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//printf("This is child process, pid is %d\n", getpid());</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">//printf("This is parent process, pid is %d, child pid is %d\n", getpid(), pid);</span></div><div class="line">        wait(<span class="literal">NULL</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"atfer fork\n"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>./a.out输出</p><pre><code>writebefore forkatfer forkatfer fork</code></pre><p>./a.out &gt; tmp.out;cat tmp.out输出</p><pre><code>writebefore forkatfer forkbefore fork（多了一句）atfer fork</code></pre><p>因为write系统调用是不带缓冲的，而标准IO库是带缓冲的。</p><p>如果标准输出连接到终端设备，则它是行缓冲，否则就是全缓冲。</p><p>首先调用write，数据直接写到标准输出。</p><p>./a.out的方式，此时标准输出为终端，那么就是行缓冲，遇到换行符输出并冲洗缓冲区，然后fork，此时缓冲区已经没数据了，所以输出一次before fork。</p><p>./a.out &gt;tmp.out，此时标准输出为文件，是全缓冲，当缓冲区满了才会冲洗缓冲区，fork的时候缓冲区是有内容的，当进程终止时，会冲洗缓冲区。</p><h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><p>当用fork启动一个子进程时，子进程就有了它自己的生命周期并将独立运行。我们可以通过在父进程中调用wait函数让父进程等待子进程的结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *status)</div></pre></td></tr></table></figure><p>wait系统调用将暂停父进程直到它的子进程结束为止。调用成功返回wait子进程的PID，它通常是已经结束运行的子进程的PID。状态信息允许父进程了解子进程的退出状态，即子进程的main函数返回的值或子进程中exit函数的退出码。如果status不是空指针，状态信息将被写入它所指向的位置。</p><p>如果调用进程没有子进程，调用就会失败，此时wait返回-1，同时errno被置为ECHILD。</p><p>如果参数status的值不是NULL，wait就会把子进程退出时的状态取出并存入其中，这是一个整数值（int），指出了子进程是正常退出还是被非正常结束的（一个进程也可以被其他进程用信号结束，我们将在以后的文章中介绍），以及正常结束时的返回值，或被哪一个信号结束的等信息。由于这些信息被存放在一个整数的不同二进制位中，所以用常规的方法读取会非常麻烦，人们就设计了一套专门的宏（macro）来完成这项工作。</p><p>WIFEXITED(status) 这个宏用来指出子进程是否为正常退出的，如果是，它会返回一个非零值。</p><p>WEXITSTATUS(status) 当WIFEXITED返回非零值时，我们可以用这个宏来提取子进程的返回值，如果子进程调用exit(5)（或者return 5或者_exit(5)）退出，WEXITSTATUS(status) 就会返回5；如果子进程调用exit(7)，WEXITSTATUS(status)就会返回7。请注意，如果进程不是正常退出的，也就是说， WIFEXITED返回0，这个值就毫无意义。</p><p>WIFSIGNALED(status) 如果子进程是因为一个未捕获的信号而终止，则此宏值为非零值。</p><p>WTERMSIG(status) 如果WIFSIGNALED非零，返回子进程因信号而中止的信号代码。</p><p>WIFSTOPPED(status) 如果子进程意外终止，它就取一个非零值。</p><p>WSTOPSIG(status) 如果WIFSTOPPED非零，返回一个信号代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">pid_t</span> pid = fork();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)</div><div class="line">    &#123;</div><div class="line">        perror(<span class="string">"fork error"</span>);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"This is child process, pid is %d\n"</span>, getpid());</div><div class="line">        sleep(<span class="number">3</span>);</div><div class="line"></div><div class="line">    <span class="built_in">exit</span>(<span class="number">5</span>); <span class="comment">// or return 5 or _exit(5);</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"This is parent process, pid is %d, child pid is %d\n"</span>, getpid(), pid);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> status;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"wait child pid:%d\n"</span>, wait(&amp;status));</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (WIFEXITED(status))</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"successful, exit code is %d\n"</span>, WEXITSTATUS(status));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><pre><code>This is parent process, pid is 733, child pid is 734This is child process, pid is 734// sleep了3秒wait child pid:734successful, exit code is 5</code></pre><p>僵尸进程</p><p>用fork来创建进程确实很有用，但你必须清楚子进程的运行情况。子进程终止时，它与父进程之间的关联还会保持，直到父进程也正常终止或父进程调用wait才告结束。因此，进程表中代表子进程的表项不会立刻释放。虽然子进程已经不再运行，但它仍然存在于系统中，因为它的退出码还需要保存起来，以备父进程今后的wait调用使用。这时它将成为一个死（defunct）进程或僵尸（zombie）进程。（子进程早于父进程结束，并且父进程没有调用wait来回收子进程就会造成僵尸进程）</p><h2 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h2><p>waitpid函数可以用来等待某个特定进程的结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> * status,<span class="keyword">int</span> options);</div></pre></td></tr></table></figure><p>pid参数指定需要等待的子进程的PID。如果它的值为-1,waitpid将返回任一子进程的信息。与wait一样，如果status不是空指针，waitpid将把状态信息写到它所指向的位置。option参数可用来改变waitpid的行为，其中最有用的一个选项是WNOHANG，它的作用是防止waitpid调用将调用者的执行挂起。你可以用这个选项来查找是否有子进程已经结束，如果没有，程序将继续执行。其他的选项和wait调用的选项相同。 因此，如果想让父进程周期性地检查某个特定的子进程是否已终止，就可以使用如下的调用方式：</p><p><code>waitpid(child_pid, (int *)0, WNOHANG);</code></p><p>如果子进程没有结束或意外终止，它就返回0，否则返回child_pid。如果waitpid失败，它将返回-1并设置errno。失败的情况包括：没有子进程（errno设置为ECHILD）、调用被某个信号中断（EINTR）或选项参数无效（EINVAL）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;fork&quot;&gt;&lt;a href=&quot;#fork&quot; class=&quot;headerlink&quot; title=&quot;fork&quot;&gt;&lt;/a&gt;fork&lt;/h2&gt;&lt;p&gt;我们可以通过调用fork创建一个新进程。这个系统调用复制当前进程，在进程表中创建一个新的表项，新表项中的许多属性与当前进程是
      
    
    </summary>
    
      <category term="C/C++" scheme="http://ysir.me/categories/C-C/"/>
    
    
      <category term="进程" scheme="http://ysir.me/tags/%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
</feed>
