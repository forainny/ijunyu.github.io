<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/uploads/favicon.ico?v=5.1.1" />






<meta name="description" content="很鱼">
<meta property="og:type" content="website">
<meta property="og:title" content="无名小站">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="无名小站">
<meta property="og:description" content="很鱼">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="无名小站">
<meta name="twitter:description" content="很鱼">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>无名小站</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">无名小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">一个兴趣使然的无名小站</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/16/Linux删除乱码文件名/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="y">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/sh.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无名小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/16/Linux删除乱码文件名/" itemprop="url">Linux删除乱码文件名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-16T23:49:04+08:00">
                2015-09-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>每个文件都有一个i节点号，通过ls -i获取</p>
<pre><code>1644970 a.out
1645007 main.c
</code></pre><p>使用find命令将文件名传递给rm命令来删除<br><code>find ./ -inum 12345 -print -exec rm {} -rf /;</code><br>12345是节点号 /;前面的空格不能少</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/16/终端程序切换前后台命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="y">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/sh.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无名小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/16/终端程序切换前后台命令/" itemprop="url">终端程序切换前后台命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-16T23:40:26+08:00">
                2015-09-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先终端下执行vim test.txt打开vim编辑器</p>
<p>按下ctrl＋z挂起程序</p>
<p>终端显示：</p>
<pre><code>[1]+  Stopped                 vim test.txt
</code></pre><p>[1]表示作业号</p>
<p>然后我们让这个程序后台执行，输入bg 1</p>
<p>终端显示：</p>
<pre><code>[1]+ vim test.txt &amp;
[1]+  Stopped                 vim test.txt
</code></pre><p>输入jobs查看后台执行的程序</p>
<pre><code>[1]+  Stopped                 vim test.txt
</code></pre><p>再输入fg 1，就可以把程序调回前台运行了</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/16/man命令详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="y">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/sh.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无名小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/16/man命令详解/" itemprop="url">man命令详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-16T23:27:53+08:00">
                2015-09-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>man</code><br>manual手册，通常放在/usr/share/man，可以修改/etc/man.config(man.conf或manpath.conf)来改善这个目录</p>
<p>例如<br><code>man date</code></p>
<pre><code>DATE(1)                   BSD General Commands Manual                  DATE(1)

DATE(1) 中数字的含义

1 用户在shell环境中可以操作的命令或可执行文件
2 系统内核可调用的函数与工具等
3 一些常用函数与函数库，大部分为C函数库
4 设备文件的说明，通常在/dev下的文件
5 配置文件或者是某些文件的格式
6 游戏
7 惯例与协议等，例如linux文件系统、网络协议、ASCII code等说明
8 系统管理员可用的管理命令
9 跟kernel有关的文件

NAME
    date -- display or set date and time
命令的完整全名及简单用途说明

SYNOPSIS
    date [-ju] [-rseconds] [-v [+|-]val[ymwdHMS]]... [+output_fmt]
    date [-jnu] [[[mm]dd]HH]MM[[cc]yy][.ss]
    date [-jnu]-finput_fmtnew_date [+output_fmt]
    date [-ddst] [-tminutes_west]
命令的基本语法

DESCRIPTION
    When invoked without arguments, thedate utility displays the current
    date and time.  Otherwise, depending on the options specified,date will
    set the date and time or print it in a user-defined way.

    Thedate utility displays the date and time read from the kernel clock.
    When used to set the date and time, both the kernel clock and the hard-
    ware clock are updated.

    Only the superuser may set the date, and if the system securelevel (see
    securelevel(8)) is greater than 1, the time may not be changed by more
    than 1 second.

    The options are as follows:

    -ddst  Set the kernel&apos;s value for daylight saving time.  Ifdst is non-
            zero, future calls to gettimeofday(2) will return a non-zero for
            tz_dsttime.

详细说明用法，-d为短参数名称，--date为完整参数名（Linux下和Mac有不同）
</code></pre><p>man page大致分为下面几个部分</p>
<pre><code>NAME            简短的命令、数据名称说明
SYNOPSIS       简短的命令执行语法简介
DESCRIPTION    较为完整的说明
OPTIONS        针对SYNOPSIS部分中，有列举的所有可用的选项说明
COMMANDS     当这个程序在执行的时候，可以在此程序中执行的命令
FILES            这个程序或数据所使用或参考或连接到的某些文件
SEE ALSO       这个命令有关的其他说明
EXAMPLE        范例
BUGS            是否有相关的错误
</code></pre><p>查询跟man命令有关的手册</p>
<p>man -f man 相当于 whatis man</p>
<p>只要有man关键字就将该说明列出来</p>
<p>man -k man 相当于 apropos man</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/16/ls-al每一列的意思/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="y">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/sh.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无名小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/16/ls-al每一列的意思/" itemprop="url">ls -al每一列的意思</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-16T23:22:07+08:00">
                2015-09-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>ls -al</code></p>
<p>查看文件信息</p>
<p>drwx——+  9 zyu  staff    306  8 19 21:15 Pictures<br>drwxr-xr-x+  6 zyu  staff    204  3 30 22:09 Public</p>
<p>第一列：文件的类型与权限<br>第一个字母代表文件类型：d目录，-文件，l链接文件，b设备文件里的可供存储的接口设备，c表示设备文件里的串行端口设备，如键盘鼠标等一次性读取设备<br>接下来三个一组，第一组为文件所有者权限，第二组为同用户组的权限，第三组为其他非本用户组的权限</p>
<p>第二列：有多少文件名连接到此节点（i-node）<br>每个文件都会将它的权限与属性记录到文件系统的i-node中，不过我们使用的目录树却是使用文件名来记录，因此每个文件名就会连接到一个i-node，这个属性记录的就是有多少不同的文件名连接到相同的一个i-node号码</p>
<p>第三列：所有者账号</p>
<p>第四列：文件所属用户组</p>
<p>第五列：容量大小，默认单位B</p>
<p>第六列：创建或最近修改日期<br>查看完整时间 ls -l –full-time</p>
<p>第七列：文件名</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/16/配置vim/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="y">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/sh.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无名小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/16/配置vim/" itemprop="url">配置vim</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-16T23:16:52+08:00">
                2015-09-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工具/" itemprop="url" rel="index">
                    <span itemprop="name">工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>vim /etc/vim/vimrc 打开vimrc</p>
<p>结尾加上</p>
<pre><code>set ts=4 ts = tabstop，缩进所使用的长度
set expandtab tab转换成空格
set autoindent 自动缩进
set number 显示行号
</code></pre><p>打开文件时跳到上一次退出的位置<br>找到Uncomment the following to have Vim jump to the last position when reopening a file取消注释掉下面的if…endif</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/16/Linux进程相关/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="y">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/sh.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无名小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/16/Linux进程相关/" itemprop="url">Linux进程相关</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-16T14:45:04+08:00">
                2015-09-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h2><p>我们可以通过调用fork创建一个新进程。这个系统调用复制当前进程，在进程表中创建一个新的表项，新表项中的许多属性与当前进程是相同的。新进程几乎与原进程一模一样，执行的代码也完全相同，但新进程有自己的数据空间、环境和文件描述符。fork和exec函数结合在一起使用就是创建新进程所需要的一切了。</p>
<p>fork之后，子进程是父进程的副本。子进程将获得父进程的数据空间、堆和栈的副本。父子进程不共享这些存储空间部分。父子进程共享正文段。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</div></pre></td></tr></table></figure>
<p>在父进程中的fork调用返回的是新的子进程的进程号PID（这个PID并不是父进程的PID，而是新建的子进程的PID）。新进程将继续执行，就像原进程一样，不同之处在于，子进程中的fork调用返回的是0。父子进程可以通过这一点来判断究竟谁是父进程，谁是子进程。如果fork失败，它将返回-1。失败通常是因为父进程所拥有的子进程数目超过了规定的限制（CHILD_MAX），此时errno将被设为EAGAIN。如果是因为进程表里没有足够的空间用于创建新的表单或虚拟内存不足，errno变量将被设为ENOMEM。</p>
<p>也就是说如果fork返回-1，表示进程创建失败；返回0，表示当前进程为子进程；返回其他值表示当前进程为父进程，并且这个值是子进程的PID。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    write(STDOUT_FILENO, <span class="string">"write\n"</span>, <span class="number">6</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"before fork\n"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">pid_t</span> pid = fork();</div><div class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)</div><div class="line">    &#123;</div><div class="line">        perror(<span class="string">"fork error"</span>);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//printf("This is child process, pid is %d\n", getpid());</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">//printf("This is parent process, pid is %d, child pid is %d\n", getpid(), pid);</span></div><div class="line">        wait(<span class="literal">NULL</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"atfer fork\n"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>./a.out输出</p>
<pre><code>write
before fork
atfer fork
atfer fork
</code></pre><p>./a.out &gt; tmp.out;cat tmp.out输出</p>
<pre><code>write
before fork
atfer fork
before fork（多了一句）
atfer fork
</code></pre><p>因为write系统调用是不带缓冲的，而标准IO库是带缓冲的。</p>
<p>如果标准输出连接到终端设备，则它是行缓冲，否则就是全缓冲。</p>
<p>首先调用write，数据直接写到标准输出。</p>
<p>./a.out的方式，此时标准输出为终端，那么就是行缓冲，遇到换行符输出并冲洗缓冲区，然后fork，此时缓冲区已经没数据了，所以输出一次before fork。</p>
<p>./a.out &gt;tmp.out，此时标准输出为文件，是全缓冲，当缓冲区满了才会冲洗缓冲区，fork的时候缓冲区是有内容的，当进程终止时，会冲洗缓冲区。</p>
<h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><p>当用fork启动一个子进程时，子进程就有了它自己的生命周期并将独立运行。我们可以通过在父进程中调用wait函数让父进程等待子进程的结束。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *status)</div></pre></td></tr></table></figure>
<p>wait系统调用将暂停父进程直到它的子进程结束为止。调用成功返回wait子进程的PID，它通常是已经结束运行的子进程的PID。状态信息允许父进程了解子进程的退出状态，即子进程的main函数返回的值或子进程中exit函数的退出码。如果status不是空指针，状态信息将被写入它所指向的位置。</p>
<p>如果调用进程没有子进程，调用就会失败，此时wait返回-1，同时errno被置为ECHILD。</p>
<p>如果参数status的值不是NULL，wait就会把子进程退出时的状态取出并存入其中，这是一个整数值（int），指出了子进程是正常退出还是被非正常结束的（一个进程也可以被其他进程用信号结束，我们将在以后的文章中介绍），以及正常结束时的返回值，或被哪一个信号结束的等信息。由于这些信息被存放在一个整数的不同二进制位中，所以用常规的方法读取会非常麻烦，人们就设计了一套专门的宏（macro）来完成这项工作。</p>
<p>WIFEXITED(status) 这个宏用来指出子进程是否为正常退出的，如果是，它会返回一个非零值。</p>
<p>WEXITSTATUS(status) 当WIFEXITED返回非零值时，我们可以用这个宏来提取子进程的返回值，如果子进程调用exit(5)（或者return 5或者_exit(5)）退出，WEXITSTATUS(status) 就会返回5；如果子进程调用exit(7)，WEXITSTATUS(status)就会返回7。请注意，如果进程不是正常退出的，也就是说， WIFEXITED返回0，这个值就毫无意义。</p>
<p>WIFSIGNALED(status) 如果子进程是因为一个未捕获的信号而终止，则此宏值为非零值。</p>
<p>WTERMSIG(status) 如果WIFSIGNALED非零，返回子进程因信号而中止的信号代码。</p>
<p>WIFSTOPPED(status) 如果子进程意外终止，它就取一个非零值。</p>
<p>WSTOPSIG(status) 如果WIFSTOPPED非零，返回一个信号代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">pid_t</span> pid = fork();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)</div><div class="line">    &#123;</div><div class="line">        perror(<span class="string">"fork error"</span>);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"This is child process, pid is %d\n"</span>, getpid());</div><div class="line">        sleep(<span class="number">3</span>);</div><div class="line"></div><div class="line">    <span class="built_in">exit</span>(<span class="number">5</span>); <span class="comment">// or return 5 or _exit(5);</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"This is parent process, pid is %d, child pid is %d\n"</span>, getpid(), pid);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> status;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"wait child pid:%d\n"</span>, wait(&amp;status));</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (WIFEXITED(status))</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"successful, exit code is %d\n"</span>, WEXITSTATUS(status));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>This is parent process, pid is 733, child pid is 734
This is child process, pid is 734
// sleep了3秒
wait child pid:734
successful, exit code is 5
</code></pre><p>僵尸进程</p>
<p>用fork来创建进程确实很有用，但你必须清楚子进程的运行情况。子进程终止时，它与父进程之间的关联还会保持，直到父进程也正常终止或父进程调用wait才告结束。因此，进程表中代表子进程的表项不会立刻释放。虽然子进程已经不再运行，但它仍然存在于系统中，因为它的退出码还需要保存起来，以备父进程今后的wait调用使用。这时它将成为一个死（defunct）进程或僵尸（zombie）进程。（子进程早于父进程结束，并且父进程没有调用wait来回收子进程就会造成僵尸进程）</p>
<h2 id="waitpid"><a href="#waitpid" class="headerlink" title="waitpid"></a>waitpid</h2><p>waitpid函数可以用来等待某个特定进程的结束。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></div><div class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> * status,<span class="keyword">int</span> options);</div></pre></td></tr></table></figure>
<p>pid参数指定需要等待的子进程的PID。如果它的值为-1,waitpid将返回任一子进程的信息。与wait一样，如果status不是空指针，waitpid将把状态信息写到它所指向的位置。option参数可用来改变waitpid的行为，其中最有用的一个选项是WNOHANG，它的作用是防止waitpid调用将调用者的执行挂起。你可以用这个选项来查找是否有子进程已经结束，如果没有，程序将继续执行。其他的选项和wait调用的选项相同。 因此，如果想让父进程周期性地检查某个特定的子进程是否已终止，就可以使用如下的调用方式：</p>
<p><code>waitpid(child_pid, (int *)0, WNOHANG);</code></p>
<p>如果子进程没有结束或意外终止，它就返回0，否则返回child_pid。如果waitpid失败，它将返回-1并设置errno。失败的情况包括：没有子进程（errno设置为ECHILD）、调用被某个信号中断（EINTR）或选项参数无效（EINVAL）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/16/exec函数族/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="y">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/sh.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无名小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/16/exec函数族/" itemprop="url">exec函数族</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-16T10:54:16+08:00">
                2015-09-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-C/" itemprop="url" rel="index">
                    <span itemprop="name">C/C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>exec函数族提供了一个在进程中启动另一个程序执行的方法。它可以根据指定的文件名或目录名找到可执行文件，并用它来取代原调用进程的数据段、代码段和堆栈段，在执行完之后，原调用进程的内容除了进程号外，其他全部被新的进程替换了。另外，这里的可执行文件既可以是二进制文件，也可以是Linux下任何可执行的脚本文件。</p>
<p>在Linux中使用exec函数族主要有两种情况：</p>
<ul>
<li>当进程认为自己不能再为系统和用户做出任何贡献时，就可以调用exec函数族中的任意一个函数让自己重生。</li>
<li>如果一个进程想执行另一个程序，那么它就可以调用fork()函数新建一个进程，然后调用exec函数族中的任意一个函数，这样看起来就像通过执行应用程序而产生了一个新进程，这种情况非常普遍，以至于Linux专门为其作了优化，我们已经知道，fork会将调用进程的所有内容原封不动的拷贝到新产生的子进程中去，这些拷贝的动作很消耗时间，而如果fork完之后我们马上就调用exec，这些辛辛苦苦拷贝来的东西又会被立刻抹掉，这看起来非常不划算，于是人们设计了一种”写时拷贝（copy-on-write）”技术，使得fork结束后并不立刻复制父进程的内容，而是到了真正实用的时候才复制，这样如果下一条语句是exec，它就不会白白作无用功了，也就提高了效率。</li>
</ul>
<p>exec函数族的6个成员函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ..., <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</div></pre></td></tr></table></figure>
<p>其中只有execve 是真正意义上的系统调用，其它都是在此基础上经过包装的库函数。</p>
<p>名字中的’l’, ‘p’, ‘e’, ‘v’的含义。</p>
<p>‘l’表示传递的参数是以列表形式出现即分开的，需要一个一个的传递，比如：<br><code>execl(&quot;/bin/ps&quot;, &quot;ps&quot;, &quot;ajx&quot;, NULL)</code><br>其中第一个参数代表传递的一个要执行的程序的路径，第二个参数必须和第一个参数的文件保持一致，后边的 ajx,NULL都是参数，而且最后一个参数必须是NULL。</p>
<p>‘v’表示函数传递的参数是以组合形式的传递而不用一个一个的传递，比如：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *buf[] = &#123;<span class="string">"ps"</span>, <span class="string">"ajx"</span>, <span class="literal">NULL</span>&#125;;</div><div class="line">execv(<span class="string">"/bin/ps"</span>, buf)</div></pre></td></tr></table></figure>
<p>其中buf这个指针数组包含了需要传递参数并且最有一个参数是NULL。</p>
<p>‘p’表示exec函数要传递可执行文件的名字，不需要传递文件路径，系统就会自动按照环境变量$PATH所指定的路径进行查找，比如：<br><code>execp(&quot;ps&quot;, &quot;ps&quot;, &quot;ajx&quot;, NULL);</code></p>
<p>‘e’表示传递给新进程的环境变量，比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *buf[] = &#123;<span class="string">"PATH=/usr/bin"</span>, <span class="literal">NULL</span>&#125;;</div><div class="line">execle(<span class="string">"./test"</span>, <span class="literal">NULL</span>, buf);</div></pre></td></tr></table></figure>
<p>那么在新的进程中环境变量PATH就变成/usr/bin下的内容了。</p>
<p>对于由exec函数启动的进程来说，它的参数表和环境加在一起的总长度是有限制的。上限由ARG_MAX给出，在Linux系统上它是128K字节。其他系统可能会设置一个非常有限的长度，这有可能会导致出现问题。POSIX规范要求ARG_MAX至少要有4096个字节。</p>
<p>一般情况下，exec函数是不会返回的，除非发生了错误，它们才会返回-1，并且会设置错误变量errno，然后从原程序的调用点接着往下执行。</p>
<p>其中最常见的原因有：</p>
<ul>
<li>找不到文件或路径，此时errno被设置为ENOENT。</li>
<li>数组argv和envp忘记用NULL结束，此时errno被设置为EFAUL。 </li>
<li>没有对应可执行文件的运行权限，此时errno被设置为EACCES。</li>
</ul>
<p>由exec启动的新进程继承了原进程的许多特性。特别地，在原进程中已打开的文件描述符在新进程中仍将保持打开，除非它们的“执行时关闭标志”（close on exec flag）被置位（详细说明对fcnt1系统调用的介绍）。任何在原进程中已打开的目录流都将在新进程中被关闭。</p>
<p><a href="http://www.farsight.com.cn/news/emb188.htm" target="_blank" rel="external">Linux下多进程编程之exec函数语法及使用实例</a><br><a href="http://blog.csdn.net/wubin1124/article/details/5002556" target="_blank" rel="external">exec函数族</a><br><a href="http://www.cplusplus.me/1079.html" target="_blank" rel="external">exec函数族的使用</a><br><a href="http://bbs.chinaunix.net/thread-4168834-1-1.html" target="_blank" rel="external">[结贴]我感觉execl的第一个参数和第二个参数有重叠，帮我看一下吧</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/10/Linux文件锁和fcntl系统调用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="y">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/sh.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无名小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/10/Linux文件锁和fcntl系统调用/" itemprop="url">Linux文件锁和fcntl系统调用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-10T18:27:07+08:00">
                2015-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-C/" itemprop="url" rel="index">
                    <span itemprop="name">C/C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Linux-中的文件锁"><a href="#Linux-中的文件锁" class="headerlink" title="Linux 中的文件锁"></a>Linux 中的文件锁</h2><p>Linux 支持的文件锁技术主要包括劝告锁（advisory lock）和强制锁（mandatory lock）这两种。此外，Linux 中还引入了两种强制锁的变种形式：共享模式强制锁（share-mode mandatory lock）和租借锁（lease）。</p>
<p>在 Linux 中，不论进程是在使用劝告锁还是强制锁，它都可以同时使用共享锁和排他锁（又称为读锁和写锁）。多个共享锁之间不会相互干扰，多个进程在同一时刻可以对同一个文件加共享锁。但是，如果一个进程对该文件加了排他锁，那么其他进程则无权再对该文件加共享锁或者排他锁，直到该排他锁被释放。所以，对于同一个文件来说，它可以同时拥有很多读者，但是在某一特定时刻，它只能拥有一个写者，它们之间的兼容关系如表所示。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th><strong>是否满足请求</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>当前加上的锁</strong></td>
<td>共享锁</td>
<td>排他锁</td>
</tr>
<tr>
<td>无</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>共享锁</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>排他锁</td>
<td>否</td>
<td>否</td>
</tr>
</tbody>
</table>
<p>共享锁=读锁，排它锁=写锁</p>
<p>也就是说当前文件没有加锁时，此时共享锁和排他锁都能够加到此文件上<br>当前文件有共享锁时，此时只能在文件上加共享锁（同一个文件可以拥有很多读者），不能加排他锁<br>当前文件有排他锁时，不能在文件上继续加锁</p>
<p>进行对已加强制锁的文件进行操作时的行为</p>
<table>
<thead>
<tr>
<th>当前锁类型</th>
<th>阻塞读</th>
<th>阻塞写</th>
<th>非阻塞读</th>
<th>非阻塞写</th>
</tr>
</thead>
<tbody>
<tr>
<td>读锁</td>
<td>正常读取数据</td>
<td>阻塞</td>
<td>正常读取数据</td>
<td>EAGAIN</td>
</tr>
<tr>
<td>写锁</td>
<td>阻塞</td>
<td>阻塞</td>
<td>EAGAIN</td>
<td>EAGAIN</td>
</tr>
</tbody>
</table>
<p>当前文件已经有一个读锁时，再加一个读锁（阻塞读，例如：fcntl(fd, F_SETLKW, &amp;flock)；非阻塞读：fcntl(fd, F_SETLK, &amp;flock))是可以加上去的；如果再加一个写锁（阻塞写：导致阻塞；非阻塞写：返回errorno）</p>
<p>当文件有一个写锁时，同理。</p>
<p>文件中的每个字节在任一时刻只能拥有一种类型的锁：共享锁（读锁）、独占锁（写锁）或解锁。</p>
<h2 id="实现文件锁"><a href="#实现文件锁" class="headerlink" title="实现文件锁"></a>实现文件锁</h2><p>Linux可以通过这几种方式来实现文件锁功能：使用fcnt1系统调用和使用lockf调用以及flock。</p>
<p>我们将主要介绍fcnt1接口，因为它是最常使用的接口。lockf和fcnt1非常相似，在Linux中，它一般作为fcnt1的备选接口。但是，fcnt1和lockf的锁定机制不能同时工作：它们使用不同的底层实现，因此决不要混合使用这两种类型的调用，而应坚持使用其中的一种。</p>
<p>fcntl不仅能锁整个文件，还能选择锁定这个文件的某一部分字节。</p>
<p>fcntl函数原型<br><code>int fcntl(int fildes, int command, ...);</code></p>
<p>fildes表示打开的文件描述符，command表示3个设置文件锁的选项</p>
<pre><code>F_GETLK
F_SETLK
F_SETLKW
</code></pre><p>当使用这三个command的时候，第三个参数必须是一个指向flock结构的指针，所以实际的函数原型应为<br><code>int fcntl(int fildes, int command, struct flock *flock_structure);</code></p>
<p>struct flock（文件锁）结构依赖具体的实现，但它至少包含下述成员：</p>
<pre><code>short l_type：取值定义在头文件fcnt1.h中：F_RDLCK（读锁）、F_UNLCK（解锁）、F_WRLCK（写锁）
short l_whence：取值必须是SEEK_SET、SEEK_CUR、SEEK_END（在头文件unistd.h中定义）中的一个。它们分别对应于文件头、当前位置和文件尾。
off_t l_start：相对于l_whence偏移的字节
off_t l_len：从l_start开始的字节数，为0表示文件末尾
pid_t l_pid：持有当前锁的进程pid
</code></pre><p>当把command设置为F_GETLK时，可以用flock_structure所描述的锁来测试fildes所代表的文件，看flock_structure锁描述的锁是否可以加到fildes所代表的文件上去。不可以加锁：把当前文件已经存在的锁写入flock_structure中，覆盖你开始设置的flock_structure；可以加锁：flock_structure的l_type变为F_UNLCK，并保持flock_structure中其他信息不变返回。(不会真正加锁，仅仅用来判断某个锁是否可以加上去，不能判断文件是否已经上锁）</p>
<p>例如：<br><code>fcntl(fildes, F_GETLK, &amp;flock_structure);</code></p>
<p>函数返回非-1表示调用成功（并不是说锁可以加上去），必须检查flock_structure结构的内容来判断其是否被修改过。因为l_pid的值被设置成持有锁的进程（如果有的话）的标识符，所以通过检查这个字段就可以很方便地判断出flock_structure结构是否被修改过（调用fcntl前，先把flock_structure的l_pid设置为-1（进程编号不会小于0），如果调用之后这个值改变了，说明是不能加锁的；也可以判断l_type，如果调用完后变成了F_UNLCK，那就说明可以加锁）。</p>
<p>command=F_SETLK时，对fildes指向的文件的某个区域加锁或解锁。加锁类型由l_type决定，区域由l_whence，l_start，l_len共同决定，这个函数立即返回成功（非-1值）或失败（-1）</p>
<p>command=F_SETLKW时，与上面的F_SETLK基本相同，只是在无法为文件添加锁时，函数将阻塞，直到可以添加锁或者获取到某个信号。</p>
<p>程序对某个文件拥有的所有锁都将在相应的文件描述符被关闭时自动清除。在程序结束时也会自动清除各种锁。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>在讨论锁定时如果未提到死锁的危险，那么这个讨论就不能算是完整的。假设两个程序想要更新同一个文件。它们需要同时更新文件中的字节1和字节2。程序A选择首先更新字节2，然后再更新字节1。程序B则是先更新字节1，然后才是字节2。 两个程序同时启动。程序A锁定字节2，而程序B锁定字节1。然后程序A尝试锁定字节1，但因为这个字节已经被程序B锁定，所以程序A将在那里等待。接着程序B尝试锁定字节2，但因为这个字节已经被程序A锁定，所以程序B也将在那里等待。 这种两个程序都无法继续执行下去的情况，就被称为死锁（deadlock或deadly embrace）。这个问题在数据库应用程序中很常见，当许多用户频繁访问同一个数据时就很容易发生死锁。大多数的商业关系型数据库都能够检测到死锁并自动解开，但Linux内核不行。这时就需要采取一些外部干涉手段，例如强制终止其中一个程序来解决这个问题。 程序员必须对这种情况提高警惕。当有多个程序都在等待获得锁时，你就需要非常小心地考虑是否会发生死锁。在本例中，死锁是非常容易避免的：两个程序只需要使用相同的顺序来锁定它们需要的字节或锁定一个更大的区域即可。</p>
<p><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-filelock/" target="_blank" rel="external">Linux 2.6 中的文件锁</a><br><a href="http://qcyhzwq001.lofter.com/tag/%E5%87%BD%E6%95%B0" target="_blank" rel="external">fcntl函数</a><br><a href="http://docs.oracle.com/cd/E19253-01/819-7052/fileio-ex-1/index.html" target="_blank" rel="external">获取锁定信息</a><br><a href="http://www.cnblogs.com/siguoya/p/3512051.html" target="_blank" rel="external">记录上锁</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/10/系统调用read与write和标准库fread与fwrite的区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="y">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/sh.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无名小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/10/系统调用read与write和标准库fread与fwrite的区别/" itemprop="url">系统调用read与write和标准库fread与fwrite的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-10T11:14:47+08:00">
                2015-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-C/" itemprop="url" rel="index">
                    <span itemprop="name">C/C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>read，write属于Linux系统调用，fread，fwrite属于C语言标准库</p>
<p>使用系统调用会影响系统的性能。与函数调用相比，系统调用的开销要大些，因为在执行系统调用时，Linux必须从运行用户代码切换到执行内核代码，然后再返回用户代码。减少这种开销的一个好方法是，在程序中尽量减少系统调用的次数，并且让每次系统调用完成尽可能多的工作。例如，每次读写大量的数据而不是每次仅读写一个字符。</p>
<p>硬件会限制对底层系统调用一次所能读写的数据块大小。例如，磁带机通常一次能写的数据块长度是10k。所以，如果你试图写的数据量不是10k的整数倍，磁带机还是会以10k为单位卷绕磁带，从而在磁带上留下了空隙。</p>
<p>当对文件区域加锁之后（使用fcntl系统调用），你必须使用底层的read和write调用来访问文件中的数据，而不要使用更高级的fread和fwrite调用，这是因为fread和fwrite会对读写的数据进行缓存，所以执行一次fread调用来读取文件中的头100个字节可能（事实上，是几乎肯定如此）会读取超过100个字节的数据，并将多余的数据在函数库中进行缓存。如果程序再次使用fread来读取下100个字节的数据，它实际上将读取已缓冲在函数库中的数据，而不会引发一个底层的read调用来从文件中取出更多的数据。 为了说明这为什么是一个问题，让我们来考虑这样一个例子：两个程序都打算更新同一个文件。假设这个文件由200个全为零的字节组成。第一个程序先开始运行，并获得该文件头100个字节的写锁。它然后使用fread来读取这100个字节。但是正如我们在前面章节中所看到的，fread会一次读取多达BUFSIZE个字节的数据，因此，它实际上把整个文件都读到了内存中，但仅把头100个字节传递给程序。 接着，第二个程序开始运行。它获得了文件后100个字节的写锁。这个操作将会成功，因为第一个程序只锁定了文件的前100个字节。第二个程序将100~199字节的数据都写成2，关闭文件并解锁，最后退出程序。这时，第一个程序锁定了文件的后100个字节，然后调用fread来读取数据。尽管真正存在于文件中的数据是100个字节的2，但是因为先前数据已经被缓存，所以程序实际上读到的数据将是100个字节的零。但如果你使用read和write，这个问题就不会发生。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/09/09/Linux应用程序应该存放在什么位置/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="y">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/sh.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="无名小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/09/09/Linux应用程序应该存放在什么位置/" itemprop="url">Linux应用程序应该存放在什么位置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-09-09T11:19:55+08:00">
                2015-09-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Linux应用程序通常存放在系统为之保留的特定目录中。系统为正常使用提供的程序，包括用于程序开发的工具，都可在目录/usr/bin中找到；系统管理员为某个特定的主机或本地网络添加的程序通常可在目录/usr/local/bin或/opt中找到。</p>
<p>系统管理员一般喜欢使用/opt和/usr/local目录，因为它们分离了厂商提供及后续添加的文件与系统本身提供的应用程序。一直保持以这种方式组织文件的好处在你需要升级操作系统时就可以看出来了，因为只有目录/opt和/usr/local里的内容需要保留。</p>
<p>我们建议对于系统级的应用程序，你可以将它放在/usr/local目录中来运行和访问所需的文件。对于开发用和个人的应用程序，最好在你的家目录中使用一个文件夹来存放它。</p>
<p>——摘自《Linux程序设计》</p>
<p>/proc目录包含了一些系统信息，驱动信息，内核信息<br>例如/proc/cpuinfo给出cpu信息</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/uploads/sh.png"
               alt="y" />
          <p class="site-author-name" itemprop="name">y</p>
           
              <p class="site-description motion-element" itemprop="description">很鱼</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">64</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">53</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/forzxy" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/ywine" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">y</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
